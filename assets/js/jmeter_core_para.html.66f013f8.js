"use strict";(self.webpackChunkcaelis_terra=self.webpackChunkcaelis_terra||[]).push([[1266],{3922:(t,e,s)=>{s.r(e),s.d(e,{comp:()=>a,data:()=>o});var i=s(6254);const n={class:"hint-container tip"},r={},a=(0,s(6995).A)(r,[["render",function(t,e){const s=(0,i.g2)("RouteLink");return(0,i.uX)(),(0,i.CE)("div",null,[e[7]||(e[7]=(0,i.Fv)('<h1 id="jmeter-参数化与动态数据详解" tabindex="-1"><a class="header-anchor" href="#jmeter-参数化与动态数据详解"><span>JMeter 参数化与动态数据详解</span></a></h1><p>参数化是性能测试的核心技能，用于模拟真实用户行为，避免重复数据导致的缓存或数据库冲突。以下是 JMeter 中实现参数化与动态数据的三种主要方法及其应用场景。</p><hr><h2 id="一、使用-csv-文件实现参数化" tabindex="-1"><a class="header-anchor" href="#一、使用-csv-文件实现参数化"><span><strong>一、使用 CSV 文件实现参数化</strong></span></a></h2><h3 id="_1-核心元件-csv-data-set-config" tabindex="-1"><a class="header-anchor" href="#_1-核心元件-csv-data-set-config"><span><strong>1. 核心元件：CSV Data Set Config</strong></span></a></h3><ul><li><strong>作用</strong>：从 CSV 文件逐行读取数据，分配给不同线程（用户）。</li><li><strong>适用场景</strong>：多用户登录、批量订单提交、测试数据多样性需求。</li></ul>',6)),(0,i.Lk)("div",n,[e[3]||(e[3]=(0,i.Lk)("p",{class:"hint-container-title"},"提示",-1)),(0,i.Lk)("p",null,[e[1]||(e[1]=(0,i.eW)("详解请参考")),(0,i.bF)(s,{to:"/jmeter/guide/config/csv.html"},{default:(0,i.k6)((()=>e[0]||(e[0]=[(0,i.eW)("CSV 数据文件配置")]))),_:1}),e[2]||(e[2]=(0,i.eW)("。"))])]),e[8]||(e[8]=(0,i.Fv)('<h3 id="_2-配置步骤" tabindex="-1"><a class="header-anchor" href="#_2-配置步骤"><span><strong>2. 配置步骤</strong></span></a></h3><ol><li><p><strong>创建 CSV 文件</strong>：</p><ul><li>文件名：<code>user_data.csv</code></li><li>内容示例：<div class="language-csv line-numbers-mode" data-highlighter="shiki" data-ext="csv" data-title="csv" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">username,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">password,</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">product_id</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">user1,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">pass123,</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">1001</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">user2,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">pass456,</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">1002</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">user3,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">pass789,</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">1003</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p><strong>添加 CSV Data Set Config</strong>：</p><ul><li>位置：右键线程组 → 添加 → 配置元件 → CSV Data Set Config</li><li>关键参数： <ul><li><strong>Filename</strong>：CSV 文件路径（建议使用绝对路径或相对路径 <code>./data/user_data.csv</code>）。</li><li><strong>Variable Names</strong>：定义变量名（如 <code>username,password,product_id</code>）。</li><li><strong>Delimiter</strong>：分隔符（默认逗号 <code>,</code>）。</li><li><strong>Recycle on EOF?</strong>：文件读取完毕后是否循环（True/False）。</li><li><strong>Stop thread on EOF?</strong>：文件读完是否停止线程（通常设为 False）。</li><li><strong>Sharing mode</strong>： <ul><li><code>All threads</code>：所有线程组共享同一文件指针。</li><li><code>Current thread group</code>：仅当前线程组独立使用。</li></ul></li></ul></li></ul></li><li><p><strong>在请求中引用变量</strong>：</p><ul><li>示例（HTTP 请求中的参数化）：<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/login?username=${username}&amp;password=${password}  </span></span>\n<span class="line"><span>/order?product_id=${product_id}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ol><div class="hint-container warning"><p class="hint-container-title">注意</p><ul><li><strong>文件编码</strong>：确保 CSV 文件为 UTF-8 无 BOM 格式，避免中文乱码。</li><li><strong>路径问题</strong>：分布式压测时，需在所有 Slave 节点相同路径下放置 CSV 文件。</li><li><strong>性能优化</strong>：大文件（如 10 万行）建议拆分为多个小文件，避免内存溢出。</li></ul></div><hr><h2 id="二、通过函数助手生成动态数据" tabindex="-1"><a class="header-anchor" href="#二、通过函数助手生成动态数据"><span><strong>二、通过函数助手生成动态数据</strong></span></a></h2><h3 id="_1-常用函数" tabindex="-1"><a class="header-anchor" href="#_1-常用函数"><span><strong>1. 常用函数</strong></span></a></h3><table><thead><tr><th><strong>函数名</strong></th><th><strong>作用</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong>__Random</strong></td><td>生成指定范围的随机整数。</td><td><code>${__Random(1,100,product_id)}</code></td></tr><tr><td><strong>__time</strong></td><td>获取当前时间戳（可格式化）。</td><td><code>${__time(yyyy-MM-dd,date)}</code></td></tr><tr><td><strong>__UUID</strong></td><td>生成唯一 UUID。</td><td><code>${__UUID}</code></td></tr><tr><td><strong>__threadNum</strong></td><td>获取当前线程编号。</td><td><code>${__threadNum}</code></td></tr></tbody></table><h3 id="_2-使用方法" tabindex="-1"><a class="header-anchor" href="#_2-使用方法"><span><strong>2. 使用方法</strong></span></a></h3><ol><li><strong>打开函数助手</strong>： <ul><li>菜单栏 → 工具 → 函数助手对话框。</li></ul></li><li><strong>生成函数表达式</strong>： <ul><li>示例：生成 1~100 的随机数 → 选择 <code>__Random</code>，输入最小值 1，最大值 100，变量名 <code>product_id</code> → 点击生成，得到 <code>${__Random(1,100,product_id)}</code>。</li></ul></li><li><strong>在请求中引用函数</strong>： <ul><li>直接在参数值中输入生成的函数表达式。</li></ul></li></ol><h3 id="_3-典型场景" tabindex="-1"><a class="header-anchor" href="#_3-典型场景"><span><strong>3. 典型场景</strong></span></a></h3><ul><li><strong>随机商品 ID</strong>：<code>/product?id=${__Random(1,1000,)}</code></li><li><strong>防缓存时间戳</strong>：<code>/api/data?t=${__time}</code></li><li><strong>唯一订单号</strong>：<code>/create_order?order_id=${__UUID}</code></li></ul><div class="hint-container warning"><p class="hint-container-title">注意</p><ul><li><strong>函数大小写敏感</strong>：如 <code>__Random</code> 不能写成 <code>__random</code>。</li><li><strong>嵌套函数</strong>：支持嵌套使用，如 <code>${__Random(1,${max_num},)}</code>。</li><li><strong>性能影响</strong>：函数调用本身消耗资源，需避免在每秒万级请求中频繁使用。</li></ul></div><hr><h2 id="三、跨线程组传递数据" tabindex="-1"><a class="header-anchor" href="#三、跨线程组传递数据"><span><strong>三、跨线程组传递数据</strong></span></a></h2><h2 id="_1-利用属性" tabindex="-1"><a class="header-anchor" href="#_1-利用属性"><span>1. 利用属性</span></a></h2><h4 id="变量-variables" tabindex="-1"><a class="header-anchor" href="#变量-variables"><span><strong>变量（Variables）</strong></span></a></h4><ul><li><strong>作用域</strong>：仅在当前线程组内有效。</li><li><strong>定义方式</strong>： <ul><li>通过 <code>用户定义的变量</code> 元件定义全局变量。</li><li>通过正则表达式提取器（如 <code>${token}</code>）动态赋值。</li></ul></li></ul><h4 id="属性-properties" tabindex="-1"><a class="header-anchor" href="#属性-properties"><span><strong>属性（Properties）</strong></span></a></h4><ul><li><strong>作用域</strong>：全局有效，跨线程组共享。</li><li><strong>定义与读取</strong>： <ul><li><strong>设置属性</strong>：使用 <code>__setProperty</code> 函数，如 <code>${__setProperty(global_token,${token},)}</code>。</li><li><strong>读取属性</strong>：使用 <code>__P</code> 或 <code>__property</code> 函数，如 <code>${__P(global_token)}</code>。</li></ul></li></ul><h4 id="跨线程组传递数据示例" tabindex="-1"><a class="header-anchor" href="#跨线程组传递数据示例"><span><strong>跨线程组传递数据示例</strong></span></a></h4><p><strong>场景</strong>：线程组1 登录获取 Token，线程组2 使用该 Token 访问需鉴权的 API。</p><p><strong>步骤</strong>：</p><ol><li><strong>线程组1（登录）</strong>： <ul><li>使用正则表达式提取器获取 Token，存入变量 <code>${token}</code>。</li><li>通过 <code>__setProperty</code> 将 Token 设置为全局属性：<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>${__setProperty(global_token,${token},)}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul></li><li><strong>线程组2（业务请求）</strong>： <ul><li>通过 <code>__P</code> 函数引用全局属性：<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Authorization: Bearer ${__P(global_token)}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul></li></ol><div class="hint-container warning"><p class="hint-container-title">注意</p><ul><li><strong>属性持久性</strong>：JMeter 重启后属性失效，需通过 <code>-J</code> 命令行参数预设属性。</li><li><strong>分布式测试</strong>：属性在 Master 节点设置后，不会自动同步到 Slave 节点（需额外处理）。</li><li><strong>线程安全</strong>：多线程并发修改同一属性时可能产生竞争，建议用 <code>__javaScript</code> 实现原子操作。</li></ul></div><h2 id="_2-文件再接法" tabindex="-1"><a class="header-anchor" href="#_2-文件再接法"><span>2. 文件再接法</span></a></h2>',25)),(0,i.Lk)("p",null,[e[5]||(e[5]=(0,i.eW)("详解请参考")),(0,i.bF)(s,{to:"/jmeter/sundry/get_para_across_thread.html"},{default:(0,i.k6)((()=>e[4]||(e[4]=[(0,i.eW)("Jmeter 跨线程组取参数值的方法")]))),_:1}),e[6]||(e[6]=(0,i.eW)("。"))]),e[9]||(e[9]=(0,i.Fv)('<hr><h2 id="四、参数化策略对比" tabindex="-1"><a class="header-anchor" href="#四、参数化策略对比"><span><strong>四、参数化策略对比</strong></span></a></h2><table><thead><tr><th><strong>方法</strong></th><th><strong>适用场景</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td><strong>CSV 参数化</strong></td><td>需要大量真实数据（如用户信息）。</td><td>数据管理清晰，支持复杂数据结构。</td><td>文件读写可能成为性能瓶颈。</td></tr><tr><td><strong>函数助手</strong></td><td>生成简单动态值（如时间戳、随机数）。</td><td>无需外部文件，灵活高效。</td><td>无法处理复杂数据依赖关系。</td></tr><tr><td><strong>属性跨线程组</strong></td><td>跨线程组共享数据（如 Token）。</td><td>全局有效，适合多阶段测试。</td><td>需要手动处理并发和分布式问题。</td></tr></tbody></table><hr><h2 id="五、实战示例-多用户登录与鉴权测试" tabindex="-1"><a class="header-anchor" href="#五、实战示例-多用户登录与鉴权测试"><span><strong>五、实战示例：多用户登录与鉴权测试</strong></span></a></h2><ol><li><strong>CSV 文件准备</strong>： <ul><li>文件名 <code>users.csv</code>，包含 <code>username,password</code>。</li></ul></li><li><strong>线程组1（登录）</strong>： <ul><li>CSV Data Set Config 读取 <code>users.csv</code>。</li><li>HTTP 请求发送登录接口，提取 Token 到变量 <code>${token}</code>。</li><li>使用 <code>${__setProperty(global_token_${username},${token},)}</code> 将每个用户的 Token 保存为独立属性。</li></ul></li><li><strong>线程组2（业务操作）</strong>： <ul><li>通过 <code>${__P(global_token_${username})}</code> 获取对应用户的 Token。</li><li>携带 Token 调用业务接口。</li></ul></li></ol><hr><p>通过灵活组合 CSV 参数化、函数助手和属性传递，可以覆盖从简单到复杂的动态数据需求，构建高仿真的性能测试场景。</p>',8))])}]]),o=JSON.parse('{"path":"/jmeter/core/para.html","title":"JMeter 参数化与动态数据详解","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","category":["JMeter"],"tag":["Core","Parameter"],"order":2,"sticky":true,"description":"JMeter 参数化与动态数据详解 参数化是性能测试的核心技能，用于模拟真实用户行为，避免重复数据导致的缓存或数据库冲突。以下是 JMeter 中实现参数化与动态数据的三种主要方法及其应用场景。 一、使用 CSV 文件实现参数化 1. 核心元件：CSV Data Set Config 作用：从 CSV 文件逐行读取数据，分配给不同线程（用户）。 适用场...","head":[["meta",{"property":"og:url","content":"https://hekun97.github.io/jmeter/core/para.html"}],["meta",{"property":"og:site_name","content":"专业治头秃"}],["meta",{"property":"og:title","content":"JMeter 参数化与动态数据详解"}],["meta",{"property":"og:description","content":"JMeter 参数化与动态数据详解 参数化是性能测试的核心技能，用于模拟真实用户行为，避免重复数据导致的缓存或数据库冲突。以下是 JMeter 中实现参数化与动态数据的三种主要方法及其应用场景。 一、使用 CSV 文件实现参数化 1. 核心元件：CSV Data Set Config 作用：从 CSV 文件逐行读取数据，分配给不同线程（用户）。 适用场..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-30T15:06:38.000Z"}],["meta",{"property":"article:tag","content":"Core"}],["meta",{"property":"article:tag","content":"Parameter"}],["meta",{"property":"article:modified_time","content":"2025-03-30T15:06:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JMeter 参数化与动态数据详解\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-30T15:06:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"专业治头秃\\",\\"url\\":\\"https://github.com/hekun97\\"}]}"]]},"git":{"createdTime":1743347198000,"updatedTime":1743347198000,"contributors":[{"name":"hekun97","username":"hekun97","email":"hek97@qq.com","commits":1,"url":"https://github.com/hekun97"}]},"readingTime":{"minutes":4.42,"words":1327},"filePathRelative":"jmeter/core/para.md","localizedDate":"2025年3月30日","excerpt":"\\n<p>参数化是性能测试的核心技能，用于模拟真实用户行为，避免重复数据导致的缓存或数据库冲突。以下是 JMeter 中实现参数化与动态数据的三种主要方法及其应用场景。</p>\\n<hr>\\n<h2><strong>一、使用 CSV 文件实现参数化</strong></h2>\\n<h3><strong>1. 核心元件：CSV Data Set Config</strong></h3>\\n<ul>\\n<li><strong>作用</strong>：从 CSV 文件逐行读取数据，分配给不同线程（用户）。</li>\\n<li><strong>适用场景</strong>：多用户登录、批量订单提交、测试数据多样性需求。</li>\\n</ul>","autoDesc":true}')},6995:(t,e)=>{e.A=(t,e)=>{const s=t.__vccOpts||t;for(const[t,i]of e)s[t]=i;return s}}}]);