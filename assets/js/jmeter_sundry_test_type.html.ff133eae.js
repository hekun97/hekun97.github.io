"use strict";(self.webpackChunkcaelis_terra=self.webpackChunkcaelis_terra||[]).push([[5375],{5403:(t,a,n)=>{n.r(a),n.d(a,{comp:()=>i,data:()=>l});var r=n(6254);const e={class:"hint-container important"},s={},i=(0,n(6995).A)(s,[["render",function(t,a){const n=(0,r.g2)("RouteLink");return(0,r.uX)(),(0,r.CE)("div",null,[a[4]||(a[4]=(0,r.Lk)("h1",{id:"详解性能测试类型",tabindex:"-1"},[(0,r.Lk)("a",{class:"header-anchor",href:"#详解性能测试类型"},[(0,r.Lk)("span",null,"详解性能测试类型")])],-1)),a[5]||(a[5]=(0,r.Lk)("p",null,"性能测试是确保系统在高负载、复杂场景下稳定运行的关键环节。以下是常见性能测试类型的详细解析，涵盖定义、目标、执行方法及实际案例，帮助你精准选择测试策略。",-1)),a[6]||(a[6]=(0,r.Lk)("hr",null,null,-1)),(0,r.Lk)("div",e,[a[3]||(a[3]=(0,r.Lk)("p",{class:"hint-container-title"},"前提条件",-1)),(0,r.Lk)("p",null,[a[1]||(a[1]=(0,r.eW)("已熟悉性能测试曲线，可参考：")),(0,r.bF)(n,{to:"/jmeter/sundry/curve_model.html"},{default:(0,r.k6)((()=>a[0]||(a[0]=[(0,r.eW)("性能测试曲线模型")]))),_:1}),a[2]||(a[2]=(0,r.eW)("。"))])]),a[7]||(a[7]=(0,r.Fv)('<h2 id="一、基准测试" tabindex="-1"><a class="header-anchor" href="#一、基准测试"><span><strong>一、基准测试</strong></span></a></h2><h3 id="_1-定义" tabindex="-1"><a class="header-anchor" href="#_1-定义"><span><strong>1. 定义</strong></span></a></h3><p>在单用户、单请求场景下，测量系统基础性能指标（如响应时间、吞吐量）。</p><h3 id="_2-目标" tabindex="-1"><a class="header-anchor" href="#_2-目标"><span><strong>2. 目标</strong></span></a></h3><ul><li>建立性能基线，确定系统在无干扰条件下的最优性能，作为后续测试的参考基准。</li><li>识别初始性能问题（如 SQL 查询效率、代码逻辑缺陷）。</li></ul><div class="hint-container tip"><p class="hint-container-title">提示</p><p>这里的后续测试的参考基准，主要包括两方面：</p><ol><li>多用户性能测试的参考基准；</li><li>软硬件发生变化后再测试，观察变化对于性能产生的影响。</li></ol></div><h3 id="_3-场景示例" tabindex="-1"><a class="header-anchor" href="#_3-场景示例"><span><strong>3. 场景示例</strong></span></a></h3><ul><li>新功能上线前验证基础性能。</li><li>硬件/软件升级后对比性能变化。</li><li>测量静态资源（如图片）的加载速度。</li></ul><h3 id="_4-执行步骤-jmeter" tabindex="-1"><a class="header-anchor" href="#_4-执行步骤-jmeter"><span><strong>4. 执行步骤（JMeter）</strong></span></a></h3><ol><li><strong>线程组设置</strong>：1 个线程，1 次循环。</li><li><strong>取样器</strong>：添加 HTTP 请求，禁用所有定时器。</li><li><strong>监听器</strong>：使用 查看结果树（<code>View Results Tree</code>） 记录响应时间。</li></ol><h3 id="_5-关键指标" tabindex="-1"><a class="header-anchor" href="#_5-关键指标"><span><strong>5. 关键指标</strong></span></a></h3><ul><li>平均响应时间（≤ 500ms 为佳）。</li><li>无错误请求（错误率 0%）。</li><li>CPU/内存占用率。</li><li>数据库查询效率。</li></ul><div class="hint-container warning"><p class="hint-container-title">注意</p><ul><li>关闭其他应用程序，减少环境干扰。</li><li>多次执行取平均值，避免偶发波动。</li></ul></div><hr><h2 id="二、负载测试" tabindex="-1"><a class="header-anchor" href="#二、负载测试"><span><strong>二、负载测试</strong></span></a></h2><h3 id="_1-定义-1" tabindex="-1"><a class="header-anchor" href="#_1-定义-1"><span><strong>1. 定义</strong></span></a></h3><p>逐步增加并发用户数，验证系统在不同负载下的表现，找到系统的<strong>最优负载</strong>和<strong>最大负载</strong>。</p><h3 id="_2-目标-1" tabindex="-1"><a class="header-anchor" href="#_2-目标-1"><span><strong>2. 目标</strong></span></a></h3><ul><li>确认系统能否处理设计容量内的请求。</li><li>发现性能瓶颈（如慢SQL、缓存失效）。</li><li>确认系统能否处理日常高峰流量。</li><li>发现性能拐点，如响应时间陡增的临界值（<strong>最大负载</strong>）。</li></ul><h3 id="_3-场景示例-1" tabindex="-1"><a class="header-anchor" href="#_3-场景示例-1"><span><strong>3. 场景示例</strong></span></a></h3><ul><li>模拟 1000 用户同时浏览商品详情页，持续 10 分钟。</li><li>验证促销活动期间 API 的吞吐量是否达标。</li></ul><h3 id="_4-执行步骤-jmeter-1" tabindex="-1"><a class="header-anchor" href="#_4-执行步骤-jmeter-1"><span><strong>4. 执行步骤（JMeter）</strong></span></a></h3><ol><li>**线程组选择：**选择 <code>Concurrency Thread Group</code> 控制加压节奏。</li><li><strong>线程组设置</strong>：阶梯式增加线程数（如 100 → 500 → 1000）。</li><li><strong>监听器</strong>：添加 <strong>汇总报告</strong>（<code>Aggregate Report</code>，分析 TPS 和错误率。</li></ol><h3 id="_5-关键指标-1" tabindex="-1"><a class="header-anchor" href="#_5-关键指标-1"><span><strong>5. 关键指标</strong></span></a></h3><ul><li>TPS（目标值：根据业务需求设定，如 ≥ 200 TPS）。</li><li>系统资源使用率（CPU ≤ 70%，内存无持续增长）。</li></ul><h3 id="_6-典型问题" tabindex="-1"><a class="header-anchor" href="#_6-典型问题"><span><strong>6. 典型问题</strong></span></a></h3><ul><li>数据库慢查询导致 TPS 下降 → 优化索引或分库分表。</li><li>线程池满导致请求排队 → 调整线程池配置。</li></ul><hr><h2 id="三、压力测试-重要" tabindex="-1"><a class="header-anchor" href="#三、压力测试-重要"><span><strong>三、压力测试</strong>（重要）</span></a></h2><h3 id="_1-定义-2" tabindex="-1"><a class="header-anchor" href="#_1-定义-2"><span><strong>1. 定义</strong></span></a></h3><p>施加超出系统设计容量的负载，测试极限性能、容错能力和故障恢复能力。</p><h3 id="_2-目标-2" tabindex="-1"><a class="header-anchor" href="#_2-目标-2"><span><strong>2. 目标</strong></span></a></h3><ul><li>找到系统崩溃的临界点<strong>最大负载</strong>。</li><li>验证降级策略和容灾机制是否生效。</li><li>验证故障后的自动恢复机制。</li></ul><h3 id="_3-场景示例-2" tabindex="-1"><a class="header-anchor" href="#_3-场景示例-2"><span><strong>3. 场景示例</strong></span></a></h3><ul><li>模拟 5000 用户抢购 100 件限量商品。</li><li>金融系统在突发流量下的熔断机制验证。</li><li>突然切断数据库连接，观察服务是否自动切换至备用节点。</li><li>数据库连接耗尽时的错误处理策略。</li></ul><h3 id="_4-执行步骤-jmeter-2" tabindex="-1"><a class="header-anchor" href="#_4-执行步骤-jmeter-2"><span><strong>4. 执行步骤（JMeter）</strong></span></a></h3><ol><li><strong>线程组选择</strong>：使用 <code>Ultimate Thread Group</code> 模拟流量尖峰。</li><li><strong>线程组设置</strong>：瞬时高并发（如 5000 线程，0 秒启动）。</li><li><strong>监控系统日志</strong>：记录错误类型（如 503 Service Unavailable）。</li></ol><h3 id="_5-关键指标-2" tabindex="-1"><a class="header-anchor" href="#_5-关键指标-2"><span><strong>5. 关键指标</strong></span></a></h3><ul><li>系统崩溃前的最大 TPS。</li><li>故障恢复时间（如 5 分钟内自动重启）。</li></ul><div class="hint-container warning"><p class="hint-container-title">注意</p><ul><li>提前备份数据，避免测试导致生产数据丢失。</li><li>压测后检查日志，分析崩溃原因（如内存溢出）。</li></ul></div><hr><h2 id="四、并发测试" tabindex="-1"><a class="header-anchor" href="#四、并发测试"><span><strong>四、并发测试</strong></span></a></h2><h3 id="_1-定义-3" tabindex="-1"><a class="header-anchor" href="#_1-定义-3"><span><strong>1. 定义</strong></span></a></h3><p>验证多用户同时操作同一功能时的数据一致性和系统行为。</p><h3 id="_2-目标-3" tabindex="-1"><a class="header-anchor" href="#_2-目标-3"><span><strong>2. 目标</strong></span></a></h3><ul><li>确保高并发下业务逻辑正确（如库存扣减，防止超卖）。</li><li>检测资源竞争问题（如死锁、脏读）。</li></ul><img src="https://hk-docs.oss-cn-chengdu.aliyuncs.com/SoftwareTest/InterfaceTest/202401251757063.png" alt="互相等待锁死" style="zoom:50%;"><h3 id="_3-场景示例-3" tabindex="-1"><a class="header-anchor" href="#_3-场景示例-3"><span><strong>3. 场景示例</strong></span></a></h3><ul><li>100 用户同时提交同一商品的订单，验证库存是否正确扣减。</li><li>多线程更新用户积分，检查最终一致性。</li><li>多人同时编辑文档的冲突处理。</li></ul><h3 id="_4-执行步骤-jmeter-3" tabindex="-1"><a class="header-anchor" href="#_4-执行步骤-jmeter-3"><span><strong>4. 执行步骤（JMeter）</strong></span></a></h3><ol><li>使用 <code>Synchronizing Timer</code> 实现多线程同时触发请求。</li><li>添加 <code>JSON Extractor</code> 提取库存字段，断言结果是否合理。</li><li>数据库监控：检查事务锁和死锁日志。</li></ol><h3 id="_5-测试设计技巧" tabindex="-1"><a class="header-anchor" href="#_5-测试设计技巧"><span><strong>5. 测试设计技巧</strong></span></a></h3><ul><li>使用事务监控工具（如DTM）</li><li>结合分布式锁（Redis Redlock）</li></ul><h3 id="_6-关键指标" tabindex="-1"><a class="header-anchor" href="#_6-关键指标"><span><strong>6. 关键指标</strong></span></a></h3><ul><li>数据一致性（如库存扣减数量 = 成功订单数）。</li><li>无死锁或线程阻塞（通过 <code>jstack</code> 分析线程状态）。</li></ul><h3 id="_7-典型问题" tabindex="-1"><a class="header-anchor" href="#_7-典型问题"><span><strong>7. 典型问题</strong></span></a></h3><ul><li>超卖：使用分布式锁（Redis Lock）或乐观锁（版本号）。</li><li>响应超时：优化事务粒度或引入异步处理。</li></ul><h3 id="_8-经典案例" tabindex="-1"><a class="header-anchor" href="#_8-经典案例"><span><strong>8. 经典案例</strong></span></a></h3><p>机票预订系统未处理并发支付时，出现同一座位被重复售出。</p><hr><h2 id="五、稳定性测试" tabindex="-1"><a class="header-anchor" href="#五、稳定性测试"><span><strong>五、稳定性测试</strong></span></a></h2><h3 id="_1-定义-4" tabindex="-1"><a class="header-anchor" href="#_1-定义-4"><span><strong>1. 定义</strong></span></a></h3><p>长时间运行测试（通常 12-24 小时），验证系统在持续负载下的可靠性。</p><h3 id="_2-目标-4" tabindex="-1"><a class="header-anchor" href="#_2-目标-4"><span><strong>2. 目标</strong></span></a></h3><ul><li>发现内存泄漏、线程阻塞、资源逐渐耗尽等问题。</li><li>确认系统在长期运行后性能是否稳定。</li><li>验证日志轮转、磁盘空间管理等机制</li></ul><h3 id="_3-场景示例-4" tabindex="-1"><a class="header-anchor" href="#_3-场景示例-4"><span><strong>3. 场景示例</strong></span></a></h3><ul><li>模拟 500 用户持续访问系统 24 小时。</li><li>验证日志文件是否滚动归档，避免磁盘占满。</li></ul><h3 id="_4-执行步骤-jmeter-4" tabindex="-1"><a class="header-anchor" href="#_4-执行步骤-jmeter-4"><span><strong>4. 执行步骤（JMeter）</strong></span></a></h3><ol><li>线程组设置：固定线程数（如 500），循环运行 24 小时。</li><li>使用 <code>Garbage Collection</code> 监控工具（如 VisualVM）观察内存趋势。</li><li>定期检查日志文件大小和数据库连接池状态。</li></ol><h3 id="_5-关键指标-3" tabindex="-1"><a class="header-anchor" href="#_5-关键指标-3"><span><strong>5. 关键指标</strong></span></a></h3><ul><li>内存使用率波动（持续增长提示内存泄漏）。</li><li>无渐进式性能下降（如每小时 TPS 下降 ≤ 1%）。</li><li>线程死锁检测。</li><li>日志错误率趋势。</li></ul><h3 id="_6-典型问题-1" tabindex="-1"><a class="header-anchor" href="#_6-典型问题-1"><span>6. 典型问题</span></a></h3><ul><li>JVM Full GC频率随时间增加</li><li>数据库连接池未释放导致耗尽</li></ul><h3 id="_7-典型案例" tabindex="-1"><a class="header-anchor" href="#_7-典型案例"><span><strong>7. 典型案例</strong></span></a></h3><p>某社交App在连续运行72小时后，因未关闭文件句柄导致服务器崩溃。</p><div class="hint-container warning"><p class="hint-container-title">注意</p><ul><li>设置监控告警（如 Prometheus + Alertmanager）。</li><li>测试后执行内存快照分析（如 Eclipse MAT）。</li></ul></div><div class="hint-container tip"><p class="hint-container-title">提示</p><p><strong>稳定性测试的三个阶段</strong></p><ol><li><p>第一个阶段：恒定压力阶段</p><p>目标是为了检验在恒定的大压力下，系统的服务是否稳定，比如是否存在吞吐量TPS指标的波动，响应延迟的抖动、毛刺等。波动情况必须在恒定的压力下进行验证，如果是波动的压力，出现吞吐量波动或者响应延迟的长尾现象会难以捕捉分析，难以区分是业务的问题还是服务的问题，为性能问题定位带来较大难度。</p></li><li><p>第二个阶段：基于一定的产品压力模型的，已上线产品</p><p>我们不难观察产品线上的典型业务及业务比例，那么在过去的七天或者一个月的时间内，产品每天的业务模型是什么样的？根据线上监控及统计不难得出。这个阶段就是为了模拟线上的这种业务模型下，也即是存在峰谷变化的压力、典型的一些Web产品每天的压力模型是比较固定的，比如每天早上9点，下午4点，晚上10点都会存在压力峰值。这种方式的模拟会为系统的稳定性带来一定的压力，如用户量突增等情况，会不会导致错误或宕机等。</p></li><li><p>第三个阶段：是在恒定压力下，引入异常干扰，注入异常用例</p><p>如CPU波动、网络延迟、主节点挂掉或重启等异常情况的出现，来充分拷打产品的稳定性和可靠性。在google的测试之道中也有提及这种模式，虽然没有更多细节暴漏出来，不过在这方面还是值得探索的。</p></li></ol><p><a href="https://cloud.tencent.com/developer/article/1891379" target="_blank" rel="noopener noreferrer">稳定性测试怎么做，这篇文章彻底讲透了！</a></p></div><hr><h2 id="六、容量测试" tabindex="-1"><a class="header-anchor" href="#六、容量测试"><span><strong>六、容量测试</strong></span></a></h2><h3 id="_1-定义-5" tabindex="-1"><a class="header-anchor" href="#_1-定义-5"><span><strong>1. 定义</strong></span></a></h3><p>通过渐进式加压，确定系统能承载的最大承载能力（用户数或数据量），为扩容提供依据。</p><h3 id="_2-目标-5" tabindex="-1"><a class="header-anchor" href="#_2-目标-5"><span><strong>2. 目标</strong></span></a></h3><ul><li>找到系统的理论容量上限（如：最大TPS，最大连接数，最大并发数，最多数据条数等）。</li><li>评估硬件升级或架构优化的必要性。</li><li>制定弹性伸缩策略阈值。</li></ul><h3 id="_3-场景示例-5" tabindex="-1"><a class="header-anchor" href="#_3-场景示例-5"><span><strong>3. 场景示例</strong></span></a></h3><ul><li>逐步增加用户数，直到响应时间超过 2 秒。</li><li>填充数据库至 1TB，测试查询性能是否达标。</li></ul><h3 id="_4-执行步骤-jmeter-5" tabindex="-1"><a class="header-anchor" href="#_4-执行步骤-jmeter-5"><span><strong>4. 执行步骤（JMeter）</strong></span></a></h3><ol><li>使用 <code>Concurrency Thread Group</code> 逐步增加并发用户（每次 +100）。</li><li>监控数据库磁盘空间和网络带宽使用情况。</li><li>记录系统崩溃前的最大用户数或数据量。</li></ol><h3 id="_5-关键指标-4" tabindex="-1"><a class="header-anchor" href="#_5-关键指标-4"><span><strong>5. 关键指标</strong></span></a></h3><ul><li>最大支持用户数（如 8000 用户时响应时间达标）。</li><li>数据库最大存储量（如 500GB 时查询性能下降）。</li></ul><h3 id="_6-关键输出" tabindex="-1"><a class="header-anchor" href="#_6-关键输出"><span><strong>6. 关键输出</strong></span></a></h3><ul><li>服务器规格与QPS的对应关系表</li><li>数据库分库分表策略验证</li></ul><h3 id="_7-优化方向" tabindex="-1"><a class="header-anchor" href="#_7-优化方向"><span><strong>7. 优化方向</strong></span></a></h3><ul><li>水平扩展：增加服务器节点或使用云弹性伸缩。</li><li>垂直扩展：升级 CPU/内存或使用 SSD 存储。</li></ul><hr><h2 id="七、其他测试类型补充" tabindex="-1"><a class="header-anchor" href="#七、其他测试类型补充"><span><strong>七、其他测试类型补充</strong></span></a></h2><table><thead><tr><th><strong>测试类型</strong></th><th><strong>关键点</strong></th></tr></thead><tbody><tr><td><strong>尖峰测试</strong></td><td>瞬时流量突增（如秒杀开始），验证系统能否快速扩容或限流。</td></tr><tr><td><strong>配置测试</strong></td><td>调整系统参数（如 JVM 堆大小），找到最优配置组合。</td></tr><tr><td><strong>故障转移测试</strong></td><td>模拟节点宕机，验证集群能否自动切换（如 Kubernetes Pod 重启）。</td></tr><tr><td><strong>拓展性测试</strong></td><td>验证系统水平/垂直扩展后的性能提升比例，常用于云原生架构。</td></tr></tbody></table><hr><h2 id="八、测试类型对比矩阵" tabindex="-1"><a class="header-anchor" href="#八、测试类型对比矩阵"><span><strong>八、测试类型对比矩阵</strong></span></a></h2><table><thead><tr><th>测试类型</th><th>负载特点</th><th>核心目标</th><th>典型指标</th></tr></thead><tbody><tr><td>基准测试</td><td>单用户/低负载</td><td>建立性能基线</td><td>单请求响应时间</td></tr><tr><td>负载测试</td><td>逐步增加<strong>系统负载量</strong></td><td>验证预期负载能力</td><td>TPS、错误率</td></tr><tr><td>压力测试</td><td>超设计负载</td><td>发现崩溃点及恢复能力</td><td>系统崩溃阈值</td></tr><tr><td>稳定性测试</td><td>长时间稳定负载</td><td>检测资源泄漏</td><td>内存泄漏率、线程阻塞</td></tr><tr><td>并发测试</td><td>高并发操作</td><td>确保数据一致性</td><td>数据冲突次数</td></tr><tr><td>容量测试</td><td>渐进式加压</td><td>确定最大容量</td><td>硬件资源与QPS关系</td></tr></tbody></table><h2 id="九、工具选择建议" tabindex="-1"><a class="header-anchor" href="#九、工具选择建议"><span><strong>九、工具选择建议</strong></span></a></h2><ul><li><strong>JMeter</strong>：适合 HTTP、JDBC、JMS 等协议，支持分布式压测。</li><li><strong>Gatling</strong>：高并发场景下性能更优，脚本用 Scala 编写。</li><li><strong>Locust</strong>：Python 编写，适合灵活定制分布式压测。</li><li><strong>云压测平台</strong>（如阿里云 PTS）：避免自建压力机，快速生成大规模流量。</li></ul><hr><h2 id="十、工具链选择建议" tabindex="-1"><a class="header-anchor" href="#十、工具链选择建议"><span><strong>十、工具链选择建议</strong></span></a></h2><ul><li><strong>快速验证场景</strong>：JMeter + Prometheus + Grafana 监控看板</li><li><strong>复杂业务流</strong>：LoadRunner 配合 Jenkins 流水线</li><li><strong>云原生架构</strong>：k6 结合 Kubernetes 压力注入</li><li><strong>全链路压测</strong>：阿里云PTS + 影子数据库</li></ul><h2 id="十一、总结-测试策略设计" tabindex="-1"><a class="header-anchor" href="#十一、总结-测试策略设计"><span><strong>十一、总结：测试策略设计</strong></span></a></h2><ol><li><strong>明确目标</strong>：根据业务需求选择测试类型（如电商大促前需执行负载+压力测试）。</li><li><strong>生产环境压测</strong>：使用流量镜像和影子表避免污染真实数据。</li><li><strong>渐进式加压</strong>：先基准测试，再逐步增加负载，逐步过渡到破坏性压力测试，避免直接高压导致系统崩溃。</li><li><strong>监控全覆盖</strong>：从应用层（APM 工具）到基础设施（服务器资源）全面监控。</li><li><strong>混沌工程结合</strong>：在压力测试中随机注入节点故障，验证系统韧性。</li><li><strong>结果驱动优化</strong>：根据测试结果制定优化清单，优先级排序（如先解决数据库锁，再优化代码）。</li></ol><div class="hint-container tip"><p class="hint-container-title">提示</p><p>通过组合使用这些测试方法，可以全面评估系统的性能表现，为架构优化提供数据支撑。</p><p>实际项目中常采用混合策略，例如在容量测试过程中同时进行稳定性监测，或在压力测试中验证系统的并发控制机制。</p></div>',107))])}]]),l=JSON.parse('{"path":"/jmeter/sundry/test_type.html","title":"详解性能测试类型","lang":"zh-CN","frontmatter":{"description":"详解性能测试类型 性能测试是确保系统在高负载、复杂场景下稳定运行的关键环节。以下是常见性能测试类型的详细解析，涵盖定义、目标、执行方法及实际案例，帮助你精准选择测试策略。 前提条件 已熟悉性能测试曲线，可参考：。 一、基准测试 1. 定义 在单用户、单请求场景下，测量系统基础性能指标（如响应时间、吞吐量）。 2. 目标 建立性能基线，确定系统在无干扰条...","head":[["meta",{"property":"og:url","content":"https://hekun97.github.io/jmeter/sundry/test_type.html"}],["meta",{"property":"og:site_name","content":"专业治头秃"}],["meta",{"property":"og:title","content":"详解性能测试类型"}],["meta",{"property":"og:description","content":"详解性能测试类型 性能测试是确保系统在高负载、复杂场景下稳定运行的关键环节。以下是常见性能测试类型的详细解析，涵盖定义、目标、执行方法及实际案例，帮助你精准选择测试策略。 前提条件 已熟悉性能测试曲线，可参考：。 一、基准测试 1. 定义 在单用户、单请求场景下，测量系统基础性能指标（如响应时间、吞吐量）。 2. 目标 建立性能基线，确定系统在无干扰条..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-16T15:42:59.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-16T15:42:59.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"详解性能测试类型\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-16T15:42:59.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"专业治头秃\\",\\"url\\":\\"https://github.com/hekun97\\"}]}"]]},"git":{"createdTime":1742139779000,"updatedTime":1742139779000,"contributors":[{"name":"hekun97","username":"hekun97","email":"hek97@qq.com","commits":1,"url":"https://github.com/hekun97"}]},"readingTime":{"minutes":10.57,"words":3171},"filePathRelative":"jmeter/sundry/test_type.md","localizedDate":"2025年3月16日","excerpt":"\\n<p>性能测试是确保系统在高负载、复杂场景下稳定运行的关键环节。以下是常见性能测试类型的详细解析，涵盖定义、目标、执行方法及实际案例，帮助你精准选择测试策略。</p>\\n<hr>\\n<div class=\\"hint-container important\\">\\n<p class=\\"hint-container-title\\">前提条件</p>\\n<p>已熟悉性能测试曲线，可参考：<a href=\\"/jmeter/sundry/curve_model.html\\" target=\\"_blank\\">性能测试曲线模型</a>。</p>\\n</div>\\n<h2><strong>一、基准测试</strong></h2>","autoDesc":true}')},6995:(t,a)=>{a.A=(t,a)=>{const n=t.__vccOpts||t;for(const[t,r]of a)n[t]=r;return n}}}]);