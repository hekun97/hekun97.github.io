"use strict";(self.webpackChunkcaelis_terra=self.webpackChunkcaelis_terra||[]).push([[4902],{2926:(r,e,n)=>{n.r(e),n.d(e,{comp:()=>o,data:()=>c});var a=n(6254);const t={},o=(0,n(6995).A)(t,[["render",function(r,e){return(0,a.uX)(),(0,a.CE)("div",null,e[0]||(e[0]=[(0,a.Fv)('<h1 id="concurrency-thread-group" tabindex="-1"><a class="header-anchor" href="#concurrency-thread-group"><span>Concurrency Thread Group</span></a></h1><p>Concurrency Thread Group：并发线程组</p><h2 id="concurrency-thread-group的介绍" tabindex="-1"><a class="header-anchor" href="#concurrency-thread-group的介绍"><span>Concurrency Thread Group的介绍</span></a></h2><ul><li>Concurrency Thread Group提供了用于配置多个线程计划的简化方法</li><li>该线程组目的是为了保持并发水平，意味着如果并发线程不够，则在运行线程中启动额外的线程</li><li>和Standard Thread Group不同，它不会预先创建所有线程，因此不会使用额外的内存</li><li>对于上篇讲到的Stepping Thread Group来说，Concurrency Thread Group是个更好的选择，因为它允许线程优雅地完成其工作</li><li>Concurrency Thread Group提供了更好的用户行为模拟，因为它使您可以更轻松地控制测试的时间，并创建替换线程以防线程在过程中完成</li></ul><h2 id="concurrency-thread-group参数讲解" tabindex="-1"><a class="header-anchor" href="#concurrency-thread-group参数讲解"><span>Concurrency Thread Group参数讲解</span></a></h2><figure><img src="/assets/jmeter/1896874-20200508133642227-1693217465.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li><strong>Target Concurrency</strong>：目标并发（线程数）</li><li><strong>Ramp Up Time</strong>：启动时间；若设置 1 min，则目标线程在1 imn内全部启动</li><li><strong>Ramp-Up Steps Count</strong>：阶梯次数；若设置 6 ，则目标线程在 1min 内分六次阶梯加压（启动线程）；<strong>每次启动的线程数</strong> = 目标线程数 / 阶梯次数 = 60 / 6 = 10</li><li><strong>Hold Target Rate Time</strong>：持续负载运行时间；若设置 2 ，则启动完所有线程后，持续负载运行 2 min，然后再结束</li><li><strong>Time Unit</strong>：时间单位（分钟或者秒）</li><li><strong>Thread Iterations Limit：<strong>线程迭代次数限制（循环次数）；默认为空，理解成永远，如果</strong>运行时间到达</strong>Ramp Up Time + Hold Target Rate Time，则停止运行线程**【不建议设置该值】**</li><li>**Log Threads Status into File：**将线程状态记录到文件中（将线程启动和线程停止事件保存为日志文件）；</li></ul><h4 id="特别注意点" tabindex="-1"><a class="header-anchor" href="#特别注意点"><span>特别注意点</span></a></h4><ul><li>Target Concurrency只是个<strong>期望值</strong>，实际不一定可以达到这个并发数，得看上面的配置**【电脑性能、网络、内存、CPU等因素都会影响最终并发线程数】**</li><li>Jmeter会根据Target Concurrency的值和当前处于<strong>活动状态的线程数</strong>来判断当前并发线程数是否达到了Target Concurrency；若没有，则会不断启动线程，尽力让并发线程数达到Target Concurrency的值</li></ul><h2 id="concurrency-thread-group和stepping-thread-group的区别" tabindex="-1"><a class="header-anchor" href="#concurrency-thread-group和stepping-thread-group的区别"><span>Concurrency Thread Group和Stepping Thread Group的区别</span></a></h2><h4 id="官方说法" tabindex="-1"><a class="header-anchor" href="#官方说法"><span>官方说法</span></a></h4><ul><li>Stepping Thread Group不提供设置启动延迟时间，阶梯增压过渡时间，阶梯释放过渡时间，但Concurrency Thread Group提供</li><li>Stepping Thread Group可以<strong>阶梯释放线程</strong>，而Concurrency Thread Group是<strong>瞬时释放</strong>（具体看下面介绍）</li><li>Stepping Thread Group设置了需要启动多少个线程就会<strong>严格执行</strong>，Concurrency Thread Group会<strong>尽力启动线程达到</strong>Target Concurrency值</li></ul><h4 id="通俗点理解" tabindex="-1"><a class="header-anchor" href="#通俗点理解"><span>通俗点理解</span></a></h4><ul><li>Stepping Thread Group 是手动场景：测试过程，按照设定好的步骤执行</li><li>Concurrency Thread Group 是目标场景：达到某个目标运行场景，测试过程不可控，动态变化</li></ul><h4 id="类比-lr" tabindex="-1"><a class="header-anchor" href="#类比-lr"><span>类比 LR</span></a></h4><ul><li>Stepping Thread Group ：设置并发用户数，持续时间等，每隔多少时间自动增加多少个用户</li><li>Concurrency Thread Group：预设一个目标并发数，每隔一段时间增加一部分并发数，直到 TPS 达到目标并发数，然后持续运行一段时间</li></ul><h2 id="concurrency-thread-group-active-threads-over-time" tabindex="-1"><a class="header-anchor" href="#concurrency-thread-group-active-threads-over-time"><span>Concurrency Thread Group + Active Threads Over Time</span></a></h2><figure><img src="/assets/jmeter/1896874-20200509113743275-622949139.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h4 id="第一个关注点-阶梯增压过程" tabindex="-1"><a class="header-anchor" href="#第一个关注点-阶梯增压过程"><span>第一个关注点：阶梯增压过程</span></a></h4><p>看Concurrency Thread Group负载预览图每次阶梯增压都是瞬时增压的，但是实际测试结果可以看到它也是有一个过渡期，并不是瞬时增压</p><h4 id="第二个关注点-持续负载运行结束后-所有线程瞬时释放" tabindex="-1"><a class="header-anchor" href="#第二个关注点-持续负载运行结束后-所有线程瞬时释放"><span>第二个关注点：持续负载运行结束后，所有线程瞬时释放</span></a></h4><ul><li>从图最后可以看到，所有线程都是瞬时释放的</li><li>普通的线程组有三种状态：启动、运行、释放；而Concurrency Thread Group的线程可以理解成只有两种状态：启动、运行；因为线程都在极短的时间内就结束了</li></ul><h2 id="concurrency-thread-group特殊情况" tabindex="-1"><a class="header-anchor" href="#concurrency-thread-group特殊情况"><span>Concurrency Thread Group特殊情况</span></a></h2><figure><img src="/assets/jmeter/1896874-20200509115853537-341125999.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>上图可以看到，活跃状态的线程上下波动的很厉害</p><h4 id="大致原因" tabindex="-1"><a class="header-anchor" href="#大致原因"><span>大致原因</span></a></h4><p>受环境稳定性影响，如电脑网络、内存、CPU；活跃线程数会有波动</p><h4 id="如何解决" tabindex="-1"><a class="header-anchor" href="#如何解决"><span>如何解决</span></a></h4><p>遇到这种情况可以多调试几次，看看情况如何</p><h4 id="结论" tabindex="-1"><a class="header-anchor" href="#结论"><span>结论</span></a></h4><ul><li>其实有波动是正常的，我们没必要纠结</li><li>我们要重点注意的是TPS</li><li>线程组的负载只是压力值，我们要测的是服务端的性能，需要关注的是服务端的TPS</li></ul><h2 id="concurrency-thread-group的扩展" tabindex="-1"><a class="header-anchor" href="#concurrency-thread-group的扩展"><span>Concurrency Thread Group的扩展</span></a></h2><ul><li>当Concurrency Thread Group与Throughput Shaping Timer（吞吐量计时器）一起使用时，可以用tstFeedback 函数的调用来动态维护实现目标RPS所需的线程数</li><li>使用此方法时， 需要将Ramp Up Time 和 Ramp-Up Steps Count 置空</li><li>但要确保 Hold Target Rate Time ≥ Throughput Shaping Timer 时间表中指定的总持续时间值（Duration）</li></ul><p>（后续实际用到的时候再补充吧）</p>',34)]))}]]),c=JSON.parse('{"path":"/jmeter/guide/threads/concurrency.html","title":"Concurrency Thread Group","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","category":["JMeter"],"tag":["Thread","Concurrency"],"order":4,"sticky":true,"description":"Concurrency Thread Group Concurrency Thread Group：并发线程组 Concurrency Thread Group的介绍 Concurrency Thread Group提供了用于配置多个线程计划的简化方法 该线程组目的是为了保持并发水平，意味着如果并发线程不够，则在运行线程中启动额外的线程 和Standa...","head":[["meta",{"property":"og:url","content":"https://hekun97.github.io/jmeter/guide/threads/concurrency.html"}],["meta",{"property":"og:site_name","content":"专业治头秃"}],["meta",{"property":"og:title","content":"Concurrency Thread Group"}],["meta",{"property":"og:description","content":"Concurrency Thread Group Concurrency Thread Group：并发线程组 Concurrency Thread Group的介绍 Concurrency Thread Group提供了用于配置多个线程计划的简化方法 该线程组目的是为了保持并发水平，意味着如果并发线程不够，则在运行线程中启动额外的线程 和Standa..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://hekun97.github.io/assets/jmeter/1896874-20200508133642227-1693217465.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-29T08:50:01.000Z"}],["meta",{"property":"article:tag","content":"Thread"}],["meta",{"property":"article:tag","content":"Concurrency"}],["meta",{"property":"article:modified_time","content":"2025-03-29T08:50:01.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Concurrency Thread Group\\",\\"image\\":[\\"https://hekun97.github.io/assets/jmeter/1896874-20200508133642227-1693217465.png\\",\\"https://hekun97.github.io/assets/jmeter/1896874-20200509113743275-622949139.png\\",\\"https://hekun97.github.io/assets/jmeter/1896874-20200509115853537-341125999.png\\"],\\"dateModified\\":\\"2025-03-29T08:50:01.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"专业治头秃\\",\\"url\\":\\"https://github.com/hekun97\\"}]}"]]},"git":{"createdTime":1743183812000,"updatedTime":1743238201000,"contributors":[{"name":"hekun97","username":"hekun97","email":"hek97@qq.com","commits":2,"url":"https://github.com/hekun97"}]},"readingTime":{"minutes":4.11,"words":1232},"filePathRelative":"jmeter/guide/threads/concurrency.md","localizedDate":"2025年3月28日","excerpt":"\\n<p>Concurrency Thread Group：并发线程组</p>\\n<h2>Concurrency Thread Group的介绍</h2>\\n<ul>\\n<li>Concurrency Thread Group提供了用于配置多个线程计划的简化方法</li>\\n<li>该线程组目的是为了保持并发水平，意味着如果并发线程不够，则在运行线程中启动额外的线程</li>\\n<li>和Standard Thread Group不同，它不会预先创建所有线程，因此不会使用额外的内存</li>\\n<li>对于上篇讲到的Stepping Thread Group来说，Concurrency Thread Group是个更好的选择，因为它允许线程优雅地完成其工作</li>\\n<li>Concurrency Thread Group提供了更好的用户行为模拟，因为它使您可以更轻松地控制测试的时间，并创建替换线程以防线程在过程中完成</li>\\n</ul>","autoDesc":true}')},6995:(r,e)=>{e.A=(r,e)=>{const n=r.__vccOpts||r;for(const[r,a]of e)n[r]=a;return n}}}]);